---
title: "테스트입니다 111222"
date: 2025-10-03
category: "개발"
tags: ["Next.js"]
thumbnail: "https://raw.githubusercontent.com/ParkYongHo1/ParkYongHo.blog/dev/mdx/images/1759474272664-______2025-03-23_133124.png"
---

# GitHub API를 활용한 서버리스 블로그 구축기

## GitHub API란?

GitHub API는 GitHub 저장소의 파일, 커밋, 브랜치 등을 프로그래밍 방식으로 제어할 수 있는 인터페이스입니다. 이를 활용하면 GitHub를 데이터베이스처럼 사용하여 서버 없이 블로그를 운영할 수 있습니다.

## 초기 설계: 분산된 메타데이터 구조

처음에는 검색 성능을 위해 메타데이터를 카테고리별, 태그별, 연도별로 분리하여 저장하는 구조를 설계했습니다.
```typescript
// 초기 구조 - 각 메타데이터를 개별적으로 저장
async function createPost(post: PostMetadata) {
  // 1. MDX 파일 저장
  await githubApi.put(`/repos/${owner}/${repo}/contents/mdx/posts/${fileName}`, {
    message: "Add post",
    content: encodedContent,
    branch: "dev",
  });

  // 2. 카테고리 메타데이터 저장
  await githubApi.put(`/repos/${owner}/${repo}/contents/mdx/metadata/categories/${category}.json`, {
    message: "Update category metadata",
    content: categoryData,
    branch: "dev",
  });

  // 3. 태그별 메타데이터 저장
  for (const tag of tags) {
    await githubApi.put(`/repos/${owner}/${repo}/contents/mdx/metadata/tags/${tag}.json`, {
      message: `Update tag ${tag}`,
      content: tagData,
      branch: "dev",
    });
  }

  // 4. 연도별 메타데이터 저장
  await githubApi.put(`/repos/${owner}/${repo}/contents/mdx/metadata/yearly/${year}.json`, {
    message: "Update yearly metadata",
    content: yearlyData,
    branch: "dev",
  });
}
```

### 문제점 발견

이 방식은 하나의 글을 작성할 때 여러 개의 커밋이 생성되었습니다. 예를 들어 태그가 3개인 글을 작성하면:

- MDX 파일: 1개 커밋
- 카테고리: 1개 커밋
- 태그 3개: 3개 커밋
- 연도별: 1개 커밋

**총 6개의 커밋이 생성되어 Git 히스토리가 지저분해졌습니다.**

## 1차 개선: GitHub Tree API 활용

여러 파일을 한 번의 커밋으로 저장하기 위해 Git의 저수준 API인 Tree API를 활용했습니다.
```typescript
async function createPostWithSingleCommit(
  githubApi: AxiosInstance,
  owner: string,
  repo: string,
  files: FileToCommit[],
  commitMessage: string
) {
  // 1. 현재 브랜치의 최신 커밋 SHA 가져오기
  const { data: refData } = await githubApi.get(
    `/repos/${owner}/${repo}/git/ref/heads/dev`
  );
  const latestCommitSha = refData.object.sha;

  // 2. 커밋의 트리 SHA 가져오기
  const { data: commitData } = await githubApi.get(
    `/repos/${owner}/${repo}/git/commits/${latestCommitSha}`
  );
  const baseTreeSha = commitData.tree.sha;

  // 3. 새 트리 생성 (모든 파일 포함)
  const tree = files.map((file) => ({
    path: file.path,
    mode: "100644",
    type: "blob",
    content: file.content,
  }));

  const { data: newTree } = await githubApi.post(
    `/repos/${owner}/${repo}/git/trees`,
    { base_tree: baseTreeSha, tree }
  );

  // 4. 새 커밋 생성
  const { data: newCommit } = await githubApi.post(
    `/repos/${owner}/${repo}/git/commits`,
    {
      message: commitMessage,
      tree: newTree.sha,
      parents: [latestCommitSha],
    }
  );

  // 5. 브랜치 참조 업데이트
  await githubApi.patch(`/repos/${owner}/${repo}/git/refs/heads/dev`, {
    sha: newCommit.sha,
  });
}
```

### 개선 효과

이제 MDX 파일과 모든 메타데이터 파일이 하나의 커밋으로 저장됩니다.

## 2차 개선: 이미지 업로드 통합

초기에는 이미지 업로드와 글 작성을 분리된 API로 구현했습니다.
```typescript
// 기존 방식 - 2개의 API, 2개의 커밋

// 프론트엔드에서 순차 호출
const imageResponse = await axios.post("/api/images", imageFormData);
await axios.post("/api/posts", { 
  title, 
  content, 
  thumbnail: imageResponse.data.url 
});
```

이 방식도 여전히 2개의 커밋이 생성되는 문제가 있었습니다.

## 최종 해결: 통합 API

이미지 업로드와 글 작성을 하나의 API로 통합하고, Tree API를 활용하여 모든 파일을 한 번에 커밋하도록 개선했습니다.
```typescript
export async function POST(request: NextRequest) {
  const formData = await request.formData();
  const title = formData.get("title") as string;
  const content = formData.get("content") as string;
  const thumbnailFile = formData.get("thumbnail") as File | null;

  const files: FileToCommit[] = [];

  // 이미지, MDX, 모든 메타데이터를 files 배열에 추가
  if (thumbnailFile) {
    files.push({ path: `mdx/images/${imageName}`, content: imageContent });
  }
  files.push({ path: mdxPath, content: mdxContent });
  files.push({ path: categoryPath, content: categoryContent });
  // ... 태그, 연도별 메타데이터

  // 모든 파일을 한 번의 커밋으로 저장
  await commitFilesToGitHub(githubApi, owner, repo, files, `Add post: ${title}`);
}
```

## 결과 비교

| 방식 | 커밋 개수 | 문제점 |
|------|-----------|--------|
| 초기 (개별 저장) | 6개 | Git 히스토리 지저분 |
| 1차 개선 (Tree API) | 2개 | 이미지와 글이 분리 |
| 최종 (통합 API) | 1개 | 해결 완료 |

## 핵심 교훈

1. GitHub Tree API를 활용하면 여러 파일을 원자적으로 커밋할 수 있습니다.
2. 관련된 작업은 하나의 API로 통합하는 것이 Git 히스토리 관리에 유리합니다.
3. FormData를 사용하면 텍스트와 파일을 함께 전송할 수 있습니다.

이러한 개선을 통해 깔끔한 Git 히스토리를 유지하면서도 서버리스 블로그를 효율적으로 운영할 수 있게 되었습니다.
