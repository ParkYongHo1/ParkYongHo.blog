---
title: "[리액트] FSD 폴더구조 알아보기"
date: 2025-12-11 13:17
category: "개발"
tags: ["리액트", "FSD"]
thumbnail: "https://raw.githubusercontent.com/ParkYongHo1/ParkYongHo.blog/main/mdx/images/1765426647850-8a496fef-a8ad-4c9a-93d1-e9f74fdd3893.png"
readingTime: "10분"
---

## “폴더 구조... 나만 이렇게 어렵나?”
처음 리액트를 알게 되고 1년 정도 지나니
UI 만들고, 상태 다루고, 라우팅하고, 전역 상태 관리하는 법 정도는 익숙해졌다.
근데 폴더 구조?
이건 여전히 감이 안 온다...

> <p>“컴포넌트를 어디까지 쪼개야 하지?"</p>
> <p>"이 로직은 이 파일에 두는 게 맞나?"</p>
> <p>"API, 훅, UI를 어떻게 나눠야 깔끔하지?"</p>


이런 질문만 반복하다 보니, 사이드 프로젝트를 진행할 때 하루의 대부분을 기능 개발이 아니라 폴더 구조 설계에 쓰고 있었다.

 **‘도대체 어떤 기준으로 폴더를 나눠야 하나?’** 이 문제로 계속 헤맸다.

그래서 폴더 구조 때문에 더 이상 헤매고 싶지 않아 폴더 구조를 공부하면서 

FSD(Feature-Sliced Design)폴더 구조에 대해 알게 되었고 

아직 완전히 익숙하진 않지만 조금씩 적용해 보면서

**“아, 이게 이런 느낌이구나”** 정도는 잡히기 시작했다. ㅎㅎ..

이번 글은 내가 FSD를 공부하며 알게 된 내용을 잊지 않기 위해 기록해 두는 글이다.

---

## 📌 FSD(Feature-Sliced Design)가 도대체 뭐길래? 🏗️

프로젝트를 처음 시작할 때는 컴포넌트나 UI 단위로 폴더를 나누는 것이 깔끔하게 느껴집니다. 

하지만 프로젝트 규모가 조금씩 커지면 문제가 발생합니다.

```
- 관심사의 분리 실패: components, containers, utils 같은 폴더만으로는 
코드가 어떤 기능을 담당하는지 명확하지 않아 코드를 찾는 데 시간이 오래 걸립니다.

- 높은 결합도: 한 기능의 코드를 수정했을 때, 예상치 못한 다른 기능에서 버그가 발생하기 쉽습니다. 
깔끔했던 구조는 금방 스파게티 코드가 됩니다.

- 재사용성 저하: 특정 UI나 로직이 다른 기능의 맥락(Context)과 섞여있어, 순수하게 분리해서 재사용하기 어렵습니다.
```

### ✨ FSD, 문제 해결의 실마리

**FSD(Feature-Sliced Design)**는 이러한 문제를 해결하기 위해 등장했습니다. 

이것은 단순한 폴더 구조가 아닌, 도메인(Domain) 중심의 엄격한 아키텍처 원칙입니다.
FSD는 프로젝트 전체를 '피자'처럼 여러 개의 **슬라이스(Slice)** 로 나누고, 각 슬라이스를 **레이어(Layer)** 라는 수평적 개념으로 교차하여 구조화합니다.

즉, 이제 UI/컴포넌트 관점이 아니라, "유저", "로그인", "상품", "댓글", "알림" 같은 **도메인(기능)** 을 중심으로 코드를 나눕니다.

![ChatGPT Image 2025년 12월 11일 오후 12_47_46.png](temp-1765425405656-3aae99ed-0bdd-43e2-82e8-70b530b7118a) 

---

### 🧩 FSD의 핵심: 레이어와 독립성

FSD의 가장 중요한 목표는 **독립성**과 **재사용성**을 극대화하는 것입니다.

상위 레이어의 하위 레이어 의존: FSD는 레이어 간의 의존성 규칙을 엄격하게 적용하여, 
상위 레이어는 하위 레이어를 참조할 수 있지만 그 반대는 불가능하도록 설계합니다. 

(예: UI를 담는 widgets은 API 로직을 담는 features를 참조할 수 있지만, features는 widgets을 참조할 수 없습니다.)

기능별 독립적인 코드: 유저(User) 도메인의 코드는 상품(Product) 도메인의 코드에 직접적으로 의존하지 않도록 격리됩니다.

이러한 규칙 덕분에 기능별로 코드가 독립적이며, 다른 기능에 영향을 덜 주게 되어 유지보수가 훨씬 쉬워집니다.

---

### 📌 왜 FSD를 선택했을까? 🧭

FSD를 선택하는 이유는 명확합니다. 프로젝트가 성장해도 구조의 일관성을 유지하고 유지보수 비용을 최소화하기 위함입니다.

### ✔ 1. 기능과 도메인별 코드가 '흩어지지 않는다'
FSD는 코드를 기능(도메인) 단위로 묶고, 그 안에서 다시 **역할(레이어)**에 따라 분리합니다.

예를 들어, 로그인 기능을 만든다고 가정해 봅시다.

| 레이어   | 역할                               | 예시 폴더 구조            | 설명                                             |
|----------|------------------------------------|----------------------------|--------------------------------------------------|
| widgets  | 여러 기능을 조합한 UI (큰 컴포넌트) | `widgets/login-form`       | 로그인 폼 전체, 상태 관리 등                    |
| features | 사용자 상호작용 및 비즈니스 로직   | `features/login-by-email`  | 이메일/비밀번호 로그인 로직, API 요청 훅        |
| entities | 도메인 데이터(상태, 모델, API)     | `entities/user`            | 유저 타입 정의, 유저 데이터 훅                  |
| shared   | 프로젝트 전체 공통 코드             | `shared/ui/button`         | 공통 UI, 유틸 함수 등                           |

보시는 것처럼, 로그인과 관련된 모든 코드는 

login이라는 단일 관심사(Slice) 아래의 레이어별 역할에 따라 깔끔하게 묶입니다. 

복잡한 API 로직을 찾기 위해 utils/api를 뒤질 필요 없이, features/login-by-email 안에서 API 관련 코드를 찾을 수 있습니다.

### ✔ 2. 엄격한 의존성 규칙으로 안정적인 구조 유지

앞서 언급했듯이, FSD의 레이어는 명확한 규칙을 가집니다.

`app → pages → widgets → features → entities → shared`


이 화살표는 **오직 참조만 가능하다** 는 의미입니다.

widgets는 features를 가져다 쓸 수 있습니다. (O)

features는 widgets을 가져다 쓸 수 없습니다. (X)

이 규칙은 개발자가 코드를 작성할 때 **잘못된 참조** 를 방지하고, 

기능 간의 결합도를 낮춰 테스트와 유지보수를 용이하게 만듭니다.

---

## 1. FSD의 6가지 핵심 레이어 (The 6 Layers)

FSD에서 가장 중요한 구조는 **프로젝트의 모든 코드를 담는 6개의 최상위 레이어**입니다.  
이 레이어들은 위에서 아래 순으로 정렬되며, **아래 레이어만 의존할 수 있는 단방향 규칙**을 가집니다.

### ✔ 레이어 구조 및 설명

| 레이어 | 설명(역할) | 의존 가능 대상 |
|-------|------------|----------------|
| **app** | 프로젝트 설정, 초기화 | 모든 레이어 |
| **pages** | 페이지 단위 UI, 라우팅 처리 | widgets 이하 |
| **widgets** | 여러 기능의 조합(큰 UI 조립품) | features 이하 |
| **features** | 사용자 상호작용, 비즈니스 로직 | entities 이하 |
| **entities** | 도메인 모델, 상태, API | shared |
| **shared** | 공통 UI, 유틸, 타입 | 없음 (최하위) |

---

## 2. 수직적 분리: 기능(Slice)와 모듈

FSD에서 **Slice**는 다음과 같은 단위를 의미합니다:

`entities/user`
`features/login`
`widgets/cart`

즉, **특정 기능이나 도메인에 대한 모든 코드가 한 곳에 모인다.**

---

### ✔ 핵심 원칙: Self-Contained (내부 모듈 격리)

각 Slice 내부 코드는 원칙적으로 **다른 Slice 내부 파일에 직접 접근하면 안 된다.**  
오직 **Public API**만 노출되어야 한다.

### 예시

#### ✅ 올바른 import
```ts
import { LoginForm } from "features/login";
```

#### ❌ 잘못된 import (내부 파일 침범)
```ts
import { LoginForm } from "features/login/ui/LoginForm.tsx";
```

---

## ✏️ 마무리

폴더 구조는 늘 어렵지만, FSD를 적용해 보면서 “기능 중심으로 생각하는 법”을 조금씩 익히게 됐다.
아직 완벽하진 않지만,  앞으로도 적용해 보며 나만의 방식으로 더 다듬어 갈 예정이다.

앞으로도 더 다듬어 가면서 **“폴더 구조 걱정은 최소화하고, 기능 개발에 더 집중하는 개발자”** 가 되고싶다...
