---
title: "use 훅 자세히 알아보기 (1)"
date: 2025-12-13 18:54
category: "개발"
tags: ["React", "Hooks"]
thumbnail: "https://raw.githubusercontent.com/ParkYongHo1/ParkYongHo.blog/main/mdx/images/1765619682818-ea9c2a91-d79f-48e0-890e-10a4ff6983be.png"
readingTime: "13분"
---



최근 사이드 프로젝트를 하나 시작했다.

서비스 전반에서 공통으로 사용할 **검색창(Search Bar)** 을 만들고 있었고, 

UX를 조금 더 좋게 만들고 싶어서 흔히 사용하는 **퀵 액션(Ctrl + K / Cmd + K)** 을 구현하기로 했다.

요구사항은 간단했다.

어느 페이지에 있든 특정 키 조합을 누르면 검색창에 포커스를 준다

자연스럽게 `window.addEventListener('keydown', ...)` 를 떠올렸고, React이니 당연히 **useEffect** 안에서 이벤트를 관리했다.

## useEffect로만 해결하기

처음 작성한 코드는 대략 이런 형태였다.

```typescript
useEffect(() => {
const handleKeyDown = (e: KeyboardEvent) => {
if (e.key === 'k' && (e.ctrlKey || e.metaKey)) {
e.preventDefault();
searchRef.current?.focus();
}
};


window.addEventListener('keydown', handleKeyDown);
return () => window.removeEventListener('keydown', handleKeyDown);
}, []);
```

동작은 잘 됐다. 
퀵 액션도 잘 먹혔고, cleanup도 있어서 문제 없어 보였다.

그런데 코드를 다시 보니 이 **useEffect** 안에는 두 가지 역할이 동시에 들어가 있었다.

1. **키보드 입력을 어떻게 처리할지에 대한 로직**
2. **이벤트를 언제 등록하고 언제 해제할지에 대한 생명주기 관리**

즉, 키 조합 로직이 바뀌어도 이 effect를 수정해야 하고

이벤트 등록 방식이 바뀌어도 이 effect를 수정해야 했다


> “이거… 단일 책임 원칙(SRP)을 잘 못 지키는 거 아닌가?”

그래서 ChatGPT에게 내 코드를 주며 이 구조가 괜찮은지, 더 나은 방법은 없는지 물어봤다.

답변은 **useCallback**을 사용한 구조였다.

```typescript
const handleKeyDown = useCallback((e: KeyboardEvent) => {
// 키 처리 로직
}, [options, callback]);


useEffect(() => {
window.addEventListener('keydown', handleKeyDown);
return () => window.removeEventListener('keydown', handleKeyDown);
}, [handleKeyDown]);
```

> “어? useCallback은 최적화용 아니었나?”

___

### 내가 알고 있던 useCallback

그동안 내가 알고 있던 useCallback은 이런 이미지였다.

- 렌더링 최적화
- 자식 컴포넌트 리렌더 방지
- 성능 문제가 있을 때 쓰는 훅

그래서 이론은 읽어봤지만 실무에서 **"지금 이 상황에 써야 한다"** 는 감각은 없었고

막상 코드에 쓰려면 손이 잘 안 갔다

이번에도 처음엔 이렇게 생각했다.

> “이 정도 코드에 굳이 useCallback까지 써야 하나?”

그런데 문제는 **‘최적화’**가 아니었다

이 케이스에서 **useCallback**의 역할은 성능 최적화가 아니었다.

이벤트 리스너는 **같은 함수 참조**로 등록/해제돼야 하고

이벤트 리스너 자체는 effect 안에 있어도 문제가 없다.

하지만 커스텀 훅처럼 재사용성과 구조가 중요한 경우에는, 

이벤트 로직을 effect 밖으로 분리하고

함수가 렌더링마다 새로 만들어지지 않도록 분리하는 편이 코드를 읽고 이해하기가 훨씬 편했다.

즉, 여기서 useCallback은

> “이 함수는 이 훅의 핵심 로직이며, 생명주기 동안 동일해야 한다”

를 보장하는 도구였다.

그래서 훅을 다시 정리해야겠다고 느꼈다

나는 **useCallback**, **useEffect**, **useRef**를 알고 있다고 생각했지만

실제로는 언제 왜 써야 하는지 정리되어 있지 않았다.

특히 커스텀 훅을 만들다 보니,

- 사이드 이펙트는 어디에 두어야 하는지
- 로직과 생명주기는 어떻게 분리해야 하는지
- 어떤 훅은 선택이고, 어떤 훅은 구조상 필수인지

이 질문들에 명확하게 답할 수 없다는 걸 깨달았다.

그래서 이 글을 시작했다.

이 글에서는 사이드 이펙트가 무엇이고,
왜 컴포넌트의 생명주기에 귀속되어야 하는지부터 정리해보려 한다.

그리고 다음 글부터는,
내가 실제로 겪었던 잘못된 패턴들을 하나씩 짚어볼 생각이다.

___

### 사이드 이펙트는 뭐가 문제였을까?

리액트에서 말하는 **사이드 이펙트**는 거창한 개념이 아니다.
쉽게 말하면 렌더링 결과와 직접적인 상관이 없는 모든 작업이다.

예를 들면 이런 것들이다.

- 이벤트 리스너 등록 / 해제
- setTimeout, setInterval
- API 요청
- 콘솔 로그
- DOM에 직접 접근하는 코드

이 공통점은 하나다.

컴포넌트가 몇 번 렌더링되든, 매번 다시 실행되면 안 된다는 것이다.

렌더링은 **계산**이고, 이펙트는 **행동**이다

리액트 컴포넌트는 기본적으로 순수한 함수로 취급된다.

같은 props와 state가 주어지면
항상 같은 JSX를 반환해야 한다는 전제가 있다.

그래서 렌더링 단계에서는 이런 코드가 있으면 안 된다.

- 이벤트를 등록한다
- 전역 객체를 건드린다
- 외부 상태를 바꾼다

이런 작업이 렌더링 중에 섞이기 시작하면,
렌더링이 몇 번 일어났는지에 따라 결과가 달라지기 시작한다.

이게 바로 리액트가 싫어하는 패턴이다.
___

### 그래서 사이드 이펙트는 “생명주기”에 묶인다

이 문제를 해결하기 위해 리액트는 명확한 규칙을 둔다.

사이드 이펙트는 렌더링이 끝난 뒤,
컴포넌트의 생명주기에 맞춰 실행되어야 한다.

이 역할을 하는 게 **useEffect**다.

**useEffect**는 단순히 **렌더링 후 실행되는 함수**가 아니다.
언제 실행되고, 언제 정리(clean up)되는지까지 포함하는 함수다

`마운트 시 실행 -> 의존성이 바뀌면 재실행 -> 언마운트 시 정리`

이 덕분에 우리는
**이 이벤트는 언제 등록되고, 언제 사라지는가**를
코드만 보고도 알 수 있다.

___

### 커스텀 훅에서 문제가 드러나기 시작했다

문제는 여기서부터였다.

컴포넌트 안에서는 **이펙트는 useEffect에 둔다** 는 규칙이 비교적 명확하다.

마운트되면 실행되고,
언마운트되면 정리된다.

```typescript
function SearchBar() {
  useEffect(() => {
    window.addEventListener('keydown', onKeyDown);
    return () => window.removeEventListener('keydown', onKeyDown);
  }, []);

  return <input />;
}
```

이 코드는 읽자마자 알 수 있다.

- 언제 이벤트가 등록되는지
- 언제 제거되는지
- 이 컴포넌트가 사라지면 모든 게 끝난다는 것

`컴포넌트는 곧 생명주기의 단위이기 때문이다.`

그런데 커스텀 훅에서는 다르다

커스텀 훅은 겉보기엔 그냥 함수다.

```typescript
export const useKeyboardShortcut = () => {
  // ...
};
```

자바스크립트 관점에서 보면,

`그냥 함수이고 호출되면 실행되며 자체적인 생명주기는 없다`

하지만 리액트 관점에서는 다르다.

`컴포넌트의 렌더링 흐름 안에서 실행되고 호출하는 쪽의 생명주기를 빌려서 동작한다`

이 이중적인 성격 때문에 문제가 생기기 시작한다.

생명주기가 코드에서 사라진다

커스텀 훅을 짜다 보면 이런 코드가 자연스럽게 떠오른다.

```typescript
export const useKeyboardShortcut = () => {
  window.addEventListener('keydown', onKeyDown);
};
```

문법적으로는 문제없다. 하지만 이 코드만 보고는 알 수 없는 게 너무 많다.

- 이 함수는 몇 번 호출될까?
- 언제 실행될까?
- 언제 정리될까?
- 컴포넌트가 사라지면 이 이벤트도 같이 사라질까?

이 질문들에 답할 수 없다.

컴포넌트에서는 당연히 보이던 생명주기가,
커스텀 훅으로 들어오는 순간 코드에서 사라진다.

그래서 커스텀 훅에서는 더 엄격해야 한다

커스텀 훅은 여러 컴포넌트에서 재사용될 수 있고,
어디서 어떻게 호출되는지 훅 자체만 봐서는 알 수 없다.

그래서 커스텀 훅에서는
사이드 이펙트를 더 엄격하게 다뤄야 한다.

- 이 로직은 정말 렌더링과 무관한가?
- 컴포넌트가 사라질 때 같이 사라져야 하는가?
- 생명주기를 명시하지 않아도 안전한가?

이 질문에 답하지 않으면, 이펙트는 의도치 않게 중복 등록되거나 남게 된다.

그래서 훅이 **구조**처럼 느껴지기 시작했다...

이 지점부터 훅은 단순한 선택지가 아니었다.


- useEffect → 생명주기를 명시하는 구조
- useCallback → 같은 함수를 계속 사용하겠다는 구조
- useRef → 렌더링과 무관한 값을 유지하는 구조


그래서 커스텀 훅에서는 더 이상

“이 훅을 써도 되나?” 가 아니라, “이 로직은 어떤 구조를 가져야 하나?” 라는 질문을 하게 된다.

___


### 마무리하며


사이드 이펙트는
어디에 있느냐보다 언제 시작되고 언제 끝나느냐가 더 중요하다는 걸 느꼈다.

그리고 그 기준은 언제나 컴포넌트의 생명주기였다.

이런 생명주기나 리액트의 규칙을 의식하면서 코드를 짜다 보니,
생각보다 쉽지 않다는 것도 함께 느끼게 됐다.

돌이켜보면 그동안은 **일단 동작하니까**라는 이유로 깊이 고민하지 않고 작성한 코드들도 많았다 ㅎㅎ...

이번 경험으로 앞으로는 하나의 기능을 만들더라도

이 로직은 언제 시작되는지 언제 정리되어야 하는지어떤 책임을 가지고 있는지를 한 번 더 고민하면서 코드를 짜보려고 한다.

아직 완전히 이해했다고 말할 수는 없지만,
적어도 이제는 **훅을 사용할 때 그 이유를 한 번 더 생각하게 됐다.**

